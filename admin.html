
<script>
  // --- CONFIG ---
  const UBIDOTS_TOKEN = "BBUS-Ghwc4x45HcRvzw1eOVF1DfBQBnAP7L";
  const PASSWORD = "Skycafe8971";
  const UBIDOTS_BASE = "https://industrial.api.ubidots.com/api/v1.6";
  const CONFIG_DEVICE = "config";
  const CONFIG_VARIABLE = "sensor_map";
  const RAW_GET_URL = `${UBIDOTS_BASE}/devices/${CONFIG_DEVICE}/${CONFIG_VARIABLE}/values?page_size=1`;
  const RAW_POST_URL = `${UBIDOTS_BASE}/devices/${CONFIG_DEVICE}/${CONFIG_VARIABLE}/values`;
  const DEVICES = Array.from({ length: 24 }, (_, i) => `skycafe-${i+1}`);
  const ACTIVE_WINDOW_MS = 60 * 60 * 1000;
  const SENSOR_WINDOW_MS = 3 * 60 * 1000;

  let mapData = {};
  let deviceStatus = {};
  let DEVICE = null; // Current truck
  let recentSensorAddresses = [];
  let fetchSensorTableID = 0;

  async function getDeviceLastTimestamp(dev) {
    try {
      const url = `${UBIDOTS_BASE}/devices/${dev}/`;
      const res = await fetch(url, { headers: { 'X-Auth-Token': UBIDOTS_TOKEN } });
      if (!res.ok) return 0;
      const js = await res.json();
      return new Date(js.last_activity).getTime() || 0;
    } catch {
      return 0;
    }
  }

  async function buildDeviceStatus() {
    deviceStatus = {};
    const now = Date.now();
    await Promise.all(DEVICES.map(async dev => {
      let lastTs = await getDeviceLastTimestamp(dev);
      deviceStatus[dev] = (now - lastTs < ACTIVE_WINDOW_MS) ? 'online' : 'offline';
    }));
  }

  document.getElementById("unlockBtn").onclick = async function() {
    const pass = document.getElementById("adminPass").value;
    if (pass.length < 8) {
      document.getElementById("authError").textContent = "Password too short.";
      return;
    }
    if (pass === PASSWORD) {
      document.getElementById("authError").textContent = "";
      document.getElementById("lockscreen").style.display = "none";
      document.getElementById("adminPage").style.display = "";
      await fetchConfigAndDeviceStatus();
    } else {
      document.getElementById("authError").textContent = "Incorrect password.";
    }
  };

  async function fetchConfigAndDeviceStatus() {
    document.getElementById("statusMsg").textContent = "Loading...";
    mapData = {};
    try {
      let res = await fetch(RAW_GET_URL + `&token=${UBIDOTS_TOKEN}`);
      if (!res.ok) throw new Error("Not found");
      let js = await res.json();
      let context = js.results && js.results.length && js.results[0].context ? js.results[0].context : {};
      mapData = context;
    } catch (e) { mapData = {}; }
    await buildDeviceStatus();
    refreshTruckSelect();
    document.getElementById("statusMsg").textContent = "";
  }

  function refreshTruckSelect() {
    const sel = document.getElementById("truckSelect");
    const noTrucksMsg = document.getElementById("noTrucksMsg");
    sel.innerHTML = '';
    if (!DEVICES.length) {
      noTrucksMsg.style.display = '';
      sel.style.display = 'none';
      document.getElementById("addTruckBtn").style.display = 'none';
      document.getElementById("delTruckBtn").style.display = 'none';
      renderSensorTable([]);
      return;
    } else {
      noTrucksMsg.style.display = 'none';
      sel.style.display = '';
      document.getElementById("addTruckBtn").style.display = '';
      document.getElementById("delTruckBtn").style.display = '';
    }
    let firstOnline = null;
    DEVICES.forEach(dev => {
      const opt = document.createElement('option');
      opt.value = dev;
      opt.textContent = dev.replace('skycafe-','SkyCafÃ© ');
      if (deviceStatus[dev] === 'offline') {
        opt.disabled = true;
        opt.textContent += ' (Offline)';
      } else if (!firstOnline) {
        firstOnline = dev;
      }
      sel.appendChild(opt);
    });
    DEVICE = firstOnline || DEVICES[0];
    sel.value = DEVICE;
    handleTruckChange();
  }

  document.getElementById("truckSelect").onchange = function(e) {
    DEVICE = e.target.value;
    handleTruckChange();
  };

  function handleTruckChange() {
    renderSensorTable([]);
    fetchLiveSensorsForTruck(DEVICE);
  }

  async function fetchLiveSensorsForTruck(dev) {
    let myID = ++fetchSensorTableID;
    let addresses = [];
    if (dev) {
      const minAgo = Date.now() - SENSOR_WINDOW_MS;
      let url = `${UBIDOTS_BASE}/variables/?device=${dev}&token=${UBIDOTS_TOKEN}`;
      try {
        let res = await fetch(url);
        if (res.ok) {
          let js = await res.json();
          addresses = js.results
            .filter(v =>
              /^[0-9a-fA-F]{16}$/.test(v.label) &&
              v.last_value && v.last_value.timestamp && v.last_value.timestamp > minAgo &&
              v.last_value.value !== 122.0 // <-- ignore "default" offline sensor value
            )
            .map(v => v.label.toUpperCase());
        }
      } catch {}
    }
    if (myID === fetchSensorTableID) {
      recentSensorAddresses = addresses;
      renderSensorTable(recentSensorAddresses);
    }
  }

  function renderSensorTable(addresses) {
    const tbl = document.getElementById("sensorTable").querySelector("tbody");
    tbl.innerHTML = '';
    if (!DEVICE || !addresses || !addresses.length) {
      tbl.innerHTML = `<tr><td colspan="4" class="text-center text-gray-500">No live sensors detected in last 3 minutes for this truck.</td></tr>`;
      return;
    }
    const sensors = mapData[DEVICE] || {};
    addresses.forEach((addr, idx) => {
      const obj = sensors[addr] || {};
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input type="text" value="${addr}" data-idx="${idx}" class="sensorAddr" style="width:120px" readonly/></td>
        <td><input type="text" value="${obj.label||''}" data-idx="${idx}" class="sensorLabel" style="width:170px"/></td>
        <td><input type="number" value="${obj.offset||0}" step="0.1" class="sensorCal" data-idx="${idx}" style="width:60px"/></td>
        <td><button class="btn text-xs px-1 py-0 bg-red-500 hover:bg-red-700 delSensorBtn">x</button></td>
      `;
      tbl.appendChild(tr);
    });
  }

  document.getElementById("addSensorBtn").onclick = async function() {
    await fetchLiveSensorsForTruck(DEVICE);
    const sensors = mapData[DEVICE] || {};
    const sensorsUpper = Object.keys(sensors).reduce((o, a) => { o[a.toUpperCase()] = true; return o; }, {});
    const unused = recentSensorAddresses.filter(addr => !sensorsUpper[addr]);
    if (unused.length === 0) {
      alert("No unused sensors available for this truck (only those active in last 3 min).");
      return;
    }
    const modal = document.getElementById("addrDropdownModal");
    const sel = document.getElementById("addrDropdown");
    sel.innerHTML = '';
    unused.forEach(addr => {
      const opt = document.createElement("option");
      opt.value = addr;
      opt.textContent = addr;
      sel.appendChild(opt);
    });
    modal.style.display = '';
    document.getElementById("addrDropdownOk").onclick = function() {
      const addr = sel.value;
      if (!addr) return;
      if (!mapData[DEVICE]) mapData[DEVICE] = {};
      mapData[DEVICE][addr] = { label: "", offset: 0 };
      modal.style.display = 'none';
      renderSensorTable(recentSensorAddresses);
    };
    document.getElementById("addrDropdownCancel").onclick = function() {
      modal.style.display = 'none';
    };
  };

  document.getElementById("sensorTable").addEventListener("click", function(e) {
    if (e.target.classList.contains("delSensorBtn")) {
      const row = e.target.closest("tr");
      const addr = row.querySelector(".sensorAddr").value.trim().toUpperCase();
      if (mapData[DEVICE]) delete mapData[DEVICE][addr];
      renderSensorTable(recentSensorAddresses);
    }
  });

  document.getElementById("sensorTable").addEventListener("input", function(e) {
    const tbl = document.getElementById("sensorTable").querySelector("tbody");
    const sensors = {};
    Array.from(tbl.querySelectorAll("tr")).forEach(tr => {
      let addr = tr.querySelector(".sensorAddr").value.trim().toUpperCase();
      if (!/^[0-9A-F]{16}$/.test(addr)) return;
      let label = tr.querySelector(".sensorLabel").value.trim();
      let offset = parseFloat(tr.querySelector(".sensorCal").value) || 0;
      sensors[addr] = { label, offset };
    });
    mapData[DEVICE] = sensors;
  });

  document.getElementById("saveBtn").onclick = async function() {
    document.getElementById("saveBtn").disabled = true;
    document.getElementById("statusMsg").textContent = "Saving...";
    try {
      let res = await fetch(RAW_POST_URL + `?token=${UBIDOTS_TOKEN}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ value: 0, context: mapData })
      });
      if (!res.ok) throw new Error("Failed to save");
      document.getElementById("statusMsg").textContent = "Saved to Ubidots!";
    } catch (e) {
      document.getElementById("statusMsg").textContent = "Failed to save.";
    }
    setTimeout(() => { document.getElementById("statusMsg").textContent = ""; }, 3000);
    document.getElementById("saveBtn").disabled = false;
  };
</script>
</body>
</html>
